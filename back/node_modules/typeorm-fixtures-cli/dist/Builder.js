"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Builder = void 0;
const fs = require("fs");
const path = require("path");
const lodash_1 = require("lodash");
const class_transformer_1 = require("class-transformer");
class Builder {
    constructor(dataSource, parser, ignoreDecorators) {
        this.dataSource = dataSource;
        this.parser = parser;
        this.ignoreDecorators = ignoreDecorators;
        this.entities = {};
    }
    async callExecutors(entity, fixture, data) {
        /* istanbul ignore else */
        for (const [method, values] of Object.entries(data.__call)) {
            /* istanbul ignore else */
            if (entity[method]) {
                await entity[method].apply(entity, this.parser.parse(values instanceof Array ? values : [values], fixture, this.entities));
            }
        }
        return entity;
    }
    async buildEntity(fixture, data) {
        const repository = this.dataSource.getRepository(fixture.entity);
        const entity = repository.create();
        // exclude prefixes to ignore __call methods
        return (0, class_transformer_1.plainToClassFromExist)(entity, data, {
            excludePrefixes: ['__'],
            ignoreDecorators: this.ignoreDecorators,
        });
    }
    async build(fixture) {
        let entity;
        let data = this.parser.parse(fixture.data, fixture, this.entities);
        let processorInstance = undefined;
        /* istanbul ignore else */
        if (data.__call && (!(0, lodash_1.isObject)(data.__call) || (0, lodash_1.isArray)(data.__call))) {
            throw new Error('invalid "__call" parameter format');
        }
        if (fixture.processor) {
            const processorPathWithoutExtension = path.join(path.dirname(fixture.processor), path.basename(fixture.processor, path.extname(fixture.processor)));
            if (!fs.existsSync(processorPathWithoutExtension) &&
                !fs.existsSync(processorPathWithoutExtension + '.ts') &&
                !fs.existsSync(processorPathWithoutExtension + '.js')) {
                throw new Error(`Processor "${fixture.processor}" not found`);
            }
            const processor = require(processorPathWithoutExtension).default;
            processorInstance = new processor();
        }
        /* istanbul ignore else */
        if (processorInstance && typeof processorInstance.preProcess === 'function') {
            data = await processorInstance.preProcess(fixture.name, data);
        }
        entity = await this.buildEntity(fixture, data);
        if (data.__call) {
            entity = await this.callExecutors(entity, fixture, data);
        }
        /* istanbul ignore else */
        if (processorInstance && typeof processorInstance.postProcess === 'function') {
            await processorInstance.postProcess(fixture.name, entity);
        }
        if (fixture.resolvedFields && Array.isArray(fixture.resolvedFields)) {
            fixture.resolvedFields.forEach((propertyName) => {
                entity[propertyName] = Promise.resolve(data[propertyName]);
            });
        }
        this.entities[fixture.name] = entity;
        return entity;
    }
}
exports.Builder = Builder;
//# sourceMappingURL=Builder.js.map